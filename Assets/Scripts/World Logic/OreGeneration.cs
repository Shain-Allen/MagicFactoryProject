using System;
using System.Collections.Generic;
using UnityEngine;
using static GridHelpers;
using static ResourceHelpers;

public class OreGeneration : MonoBehaviour
{
	// Determines the maximum radial distance of the resources from the spawn center
	private const float MAX_RADIUS = 8.5f;
	// Essentially translates to % of all tiles that are the center of an resource vein.
	private const float SPAWN_CHANCE = 0.0003f;

	/* GenerateResources procedurally places resourceName in a chunk based off of the seed.
     * PRECONDITIONS: chunkX and chunkY are between INT32MIN/128 and INT32MAX/128
     * cont.: Seed must be between 0 and INT32MAX
     * POSTCONDITIONS: Only the inputted chunk will be altered
     * Resources generated by this function will not overwrite any other resources already present
     * HELPERS: GetChunkID, GenerateResourcesInChunk
     */
	public static void GenerateChunkResources(GridControl grid, int seed, Vector2Int chunkPos)
	{
		GameObject curChunkParent = GetChunkParentByChunk(grid, chunkPos);
		if (curChunkParent)
			return;
		curChunkParent = Instantiate(grid.chunkParentObject, ((Vector2)GetMinPosInChunk(chunkPos)), Quaternion.identity, grid.transform);
		curChunkParent.name = $"({chunkPos.x},{chunkPos.y})";
		grid.worldChunks.Add(chunkPos, curChunkParent);

		// 1st  4th  7th (This shows the order of chunk loading == priority order)
		// 2nd [5th] 8th ('5th' is the chunk currently generating)
		// 3rd  6th  9th (Only '5th' will have resources placed in it)
		for (int x = -1; x <= 1; x++)
			for (int y = 1; y >= -1; y--)
				GenerateResourcesInChunk(grid, seed, chunkPos, new Vector2Int(chunkPos.x + x, chunkPos.y + y), curChunkParent);
	}

	/* Spawns all resources that have a center within fromChunkX/Y chunk but only places the ones inside chunkX/Y
     * Note: This is done because without this, resource veins will never go over chunk borders
     * cont.: This is the only way to ensure that the world generation will not be affected by the order of chunk generation
     * PRECONDITIONS: All the "Edge" variables are the edges (X and Y) of the chunk
     * cont.: Edges are always inclusive, meaning for Chunk 0,0 they are 0, 127, 0, 127
     * HELPERS: GetChunkID, GetSpawnLocations, SpawnVein
     */
	private static void GenerateResourcesInChunk(GridControl grid, int seed, Vector2Int generatingChunkPos, Vector2Int loadingChunk, GameObject curChunkParent)
	{
		System.Random randGen = new System.Random(seed - GetChunkID(loadingChunk));
		// Note that the z-Axis position is used to record which resource is being generated
		List<Vector3Int> resourceSpawns = GetVeinLocations(randGen, GetMinPosInChunk(loadingChunk), grid.oreNames.Count);

		randGen = new System.Random(seed - GetChunkID(generatingChunkPos));
		Vector2Int bottomLeftBound = GetMinPosInChunk(generatingChunkPos);
		Vector2Int topRightBound = new Vector2Int(bottomLeftBound.x + ChunkManager.CHUNK_SIZE - 1, bottomLeftBound.y + ChunkManager.CHUNK_SIZE - 1);
		foreach (Vector3Int veinCenter in resourceSpawns)
			SpawnVein(grid, grid.oreNames[veinCenter.z], veinCenter, randGen, bottomLeftBound, topRightBound, curChunkParent);
	}

	/* GetSpawnLocations gets the center of each resource vein within the chunk
     * PRECONDITIONS: All the edges are within INT32MIN and INT32MAX
     * POSTCONDITIONS: Returns a List of Vector3s with the positions of all the vein centers
     * cont.: All positions have a 0 in the Z coordinate
     * cont.: ALl positions are within (or equal to) the edges
     */
	private static List<Vector3Int> GetVeinLocations(System.Random randGen, Vector2Int minPos, int numTypesResources)
	{
		List<Vector3Int> veinLocations = new List<Vector3Int>();

		for (int x = minPos.x; x < minPos.x + ChunkManager.CHUNK_SIZE; x++)
			for (int y = minPos.y; y < minPos.y + ChunkManager.CHUNK_SIZE; y++)
				if (randGen.NextDouble() <= SPAWN_CHANCE)
					veinLocations.Add(new Vector3Int(x, y, randGen.Next(numTypesResources)));

		return veinLocations;
	}

	/* SpawnVein takes a Vector3Int the represents the center of a vein, and spawns resources into the world around it
     * PRECONDITIONS: Center is inside of the bounds of the edges
     * POSTCONDITIONS: All resources for the vein will be Instantiated and added to the oreObjects dictionary
     * cont.: Resources will never be placed outside of the edges
     * HELPERS: insideBorder
     */
	private static void SpawnVein(GridControl grid, BaseResource resourceName, Vector3Int veinCenter, System.Random randGen, Vector2Int bottomLeftBound, Vector2Int topRightBound, GameObject curChunkParent)
	{
		// rad will determine the radius of the vein by a random amount up to 3
		double rad = MAX_RADIUS - (randGen.NextDouble() * MAX_RADIUS / 2);
		// maxRad will always encompass all resources for the vein, used solely for the for-loops
		int maxRad = (int)Math.Ceiling(rad);
		double dist, oddsOfResource;
		bool spotIsEmpty;
		BaseResource tempResource;
		Vector2Int resourcePos;

		// For loops essentially look at the square around the center where MAX_RADIUS is contained, but doesn't go off the edge
		for (int x = veinCenter.x - maxRad; x <= veinCenter.x + maxRad; x++)
			for (int y = veinCenter.y - maxRad; y <= veinCenter.y + maxRad; y++)
			{
				resourcePos = new Vector2Int(x, y);

				dist = Vector2.Distance(resourcePos, new Vector2(veinCenter.x, veinCenter.y));
				spotIsEmpty = !GetResourceAt<BaseResource>(grid, resourcePos);
				oddsOfResource = dist <= rad ? 1 - Math.Pow(dist / rad, 3) : 0;

				if (randGen.NextDouble() <= oddsOfResource && insideBorder(resourcePos, bottomLeftBound, topRightBound) && dist <= rad && spotIsEmpty)
				{
					tempResource = Instantiate(resourceName, ((Vector2)resourcePos), Quaternion.identity, curChunkParent.transform);
					tempResource.Generate(grid);
				}
			}
	}
}